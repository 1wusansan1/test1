'''
什么是算法 :
算法是为逐步解决问题而设计的一系列通用指令。给定某个输入，算法能得到对应的结果——算法就是解决问题的方法。程序则是用某种编程语言对算法编码
'''


# 例如：求1到100的累加和
def sum1(n):
    sum = 0
    i = 1
    while i <= n:
        sum += i
        i += 1
    return sum


def sum2(n):
    sum = 0
    if n % 2 == 0:
        sum = (1 + n) * n // 2
    else:
        sum = (1 + n - 1) * (n - 1) // 2 + n
    return sum


def sum3(n):
    if n == 1:
        return 1
    return n + sum3(n - 1)


if __name__ == '__main__':
    print(sum1(100))
    print(sum2(101))
    print(sum3(100))


'''
1. 时间复杂度:
    时间复杂度是算法`执行时间``随输入规模增长而增长`的量度，通常用大 O 记号表示。
    它反映了算法在解决问题时所耗费的时间资源，也可以理解为算法的运行效率。时间复杂度分析的目的是确定算法执行时间与输入规模n之间的关系 。
    算法执行需要的时间，理论上只能通过上机来测试出来，但是我们不可能对所有的算法都来上机测试。我们只需要知道哪个算法用时比较多即可。
    `一个算法花费的时间与算法中基本操作语句的执行次数成正比，哪个算法中语句执行次数多，哪个算法用时就长`。 
    简单算法的时间复杂度举例 :
        O(1)
            运算次数为常数的算法 。
            def sum2(n):
                sum = (1 + n) * n  // 2
                return sum
            不管n的值为多少， 单条语句操作的频度为1，即使他有成千上万条操作，也只是个较大常数，这一类的时间复杂度为O(1) 。
        O(n)
            def sum1(n):
                sum = 0
                for i in range(1, n+1):
                    sum += i
                return sum
            上面代码中第二行频度1，第三行频度为n，第四行频度为n，第四行频度为1，所以1+n+n+1=2n+1。所以时间复杂度O(n)。这一类算法中操作次数和
            n正比线性增长。 
        O(logn)
            一个算法如果能在每个步骤去掉一半数据元素，如二分检索，通常它就取 O(logn)时间 。
            i=1
            while i<=n:
                i = i*2
        O(n²) 
            sum=0
            for i in range(1,n+1):
                for j in range(1,n+1):
                    sum += 1
            第一行频度1，第二行n，第三行n²，第四行n² ,  2n²  + n + 1 =  O(n²) 
    时间复杂度从小到大排序：  O(1) < O(logn) < O(n) ＜ O(nlogn) ＜ O(n^2) ＜ O(n^3) ＜ O(2^n) ＜ O(n!) ＜ O(n^n)
'''


'''
2. 空间复杂度:
    空间复杂度是衡量一个算法在运行过程中临时占用存储空间大小。  也是使用大O表示。
    O(1)
        占用空间，不随着输入规模n发生变化，保持为常数。
        def sum1(n):
            sum = 0
            for i in range(1, n+1):
                sum += i
            return sum
    O（n）
        def rec_sum(n):
            if n == 1:
                return 1
            return n + rec_sum(n-1)
        每次递归都会在栈上开辟空间，也就是开辟栈帧。一共要开辟N − 1层，所以通过大O 渐进法推导出这个代码空间复杂度就是O (n)
'''

'''
3. 可读性、健壮性
    可读性，容易理解、容易编程和调试、容易维护
    健壮性，考虑情况全面，不容以出现运行错误。
'''


